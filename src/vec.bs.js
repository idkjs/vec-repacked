// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require("bs-platform/lib/js/array.js");
var Curry = require("bs-platform/lib/js/curry.js");
var $$Buffer = require("bs-platform/lib/js/buffer.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");

function make(grOpt, cOpt, param) {
  var gr = grOpt !== undefined ? grOpt : 2;
  var c = cOpt !== undefined ? cOpt : 0;
  if (gr <= 1) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "growth_rate <= 1",
          Error: new Error()
        };
  }
  if (c < 0) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "capacity < 0",
          Error: new Error()
        };
  }
  return {
          growth_rate: gr,
          length: 0,
          data: Caml_array.caml_make_vect(c, 0)
        };
}

function length(v) {
  return v.length;
}

function capacity(v) {
  return v.data.length;
}

function growth_rate(v) {
  return v.growth_rate;
}

function set_growth_rate(gr, v) {
  if (gr <= 1) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "growth_rate <= 1",
          Error: new Error()
        };
  }
  v.growth_rate = gr;
  
}

function clear(v) {
  v.length = 0;
  v.data = [];
  
}

function get_exn(v, i) {
  if (i < 0 || i >= v.length) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "Index out of range",
          Error: new Error()
        };
  }
  return Caml_array.get(v.data, i);
}

function set_exn(v, i, a) {
  if (i < 0 || i >= v.length) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "Index out of range",
          Error: new Error()
        };
  }
  return Caml_array.set(v.data, i, a);
}

function get(v, i) {
  if (i < 0 || i >= v.length) {
    return ;
  } else {
    return Caml_option.some(Caml_array.get(v.data, i));
  }
}

function set(v, i, a) {
  if (i >= 0 && i < v.length) {
    Caml_array.set(v.data, i, a);
    return true;
  } else {
    return false;
  }
}

function ensure_capacity(c, v) {
  var capacity = v.data.length;
  if (c < 0) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "capacity < 0",
          Error: new Error()
        };
  }
  if (c <= capacity) {
    return ;
  }
  var cap = capacity === 0 ? v.growth_rate : capacity;
  var c$1 = c;
  while(cap < c$1) {
    cap = cap * v.growth_rate;
  };
  var data = Caml_array.caml_make_vect(cap | 0, 0);
  $$Array.blit(v.data, 0, data, 0, v.length);
  v.data = data;
  
}

function reserve(c, v) {
  if (c < 0) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "amount_to_reserve < 0",
          Error: new Error()
        };
  }
  return ensure_capacity(v.data.length + c | 0, v);
}

function shrink_to_fit(v) {
  if (v.data.length <= v.length) {
    return ;
  }
  var data = Caml_array.caml_make_vect(v.length, 0);
  $$Array.blit(v.data, 0, data, 0, v.length);
  v.data = data;
  
}

function push(val$prime, v) {
  ensure_capacity(v.length + 1 | 0, v);
  var length = v.length;
  v.length = length + 1 | 0;
  return Caml_array.set(v.data, length, val$prime);
}

function pop(v) {
  if (v.length === 0) {
    return ;
  }
  var val$prime = Caml_array.get(v.data, v.length - 1 | 0);
  Caml_array.set(v.data, v.length - 1 | 0, 0);
  v.length = v.length - 1 | 0;
  return Caml_option.some(val$prime);
}

function singleton(a) {
  return {
          growth_rate: 2,
          length: 1,
          data: [a]
        };
}

function map(f, v) {
  var v2 = make(v.growth_rate, v.length, undefined);
  v2.length = v.length;
  for(var i = 0 ,i_finish = v.length; i < i_finish; ++i){
    Caml_array.set(v2.data, i, Curry._1(f, Caml_array.get(v.data, i)));
  }
  return v2;
}

function mapi(f, v) {
  var v2 = make(v.growth_rate, v.length, undefined);
  v2.length = v.length;
  for(var i = 0 ,i_finish = v.length; i < i_finish; ++i){
    Caml_array.set(v2.data, i, Curry._2(f, i, Caml_array.get(v.data, i)));
  }
  return v2;
}

function map_in_place(f, v) {
  for(var i = 0 ,i_finish = v.length; i < i_finish; ++i){
    Caml_array.set(v.data, i, Curry._1(f, Caml_array.get(v.data, i)));
  }
  
}

function map2(f, v1, v2) {
  var total_l = Math.imul(v1.length, v2.length);
  var max_gr = v1.growth_rate > v2.growth_rate ? v1.growth_rate : v2.growth_rate;
  var v = make(max_gr, total_l, undefined);
  v.length = total_l;
  var idx = 0;
  for(var i = 0 ,i_finish = v1.length; i < i_finish; ++i){
    for(var j = 0 ,j_finish = v2.length; j < j_finish; ++j){
      Caml_array.set(v.data, idx, Curry._2(f, Caml_array.get(v1.data, i), Caml_array.get(v2.data, j)));
      idx = idx + 1 | 0;
    }
  }
  return v;
}

function apply(f, v) {
  return map2((function (prim, prim$1) {
                return Curry._1(prim, prim$1);
              }), f, v);
}

function flatten(vs) {
  var max_gr = 0;
  var total_l = 0;
  for(var i = 0 ,i_finish = vs.length; i < i_finish; ++i){
    var crr_v = Caml_array.get(vs.data, i);
    var v_gr = crr_v.growth_rate;
    if (max_gr < v_gr) {
      max_gr = v_gr;
    }
    total_l = total_l + crr_v.length | 0;
  }
  var v = make(max_gr, total_l, undefined);
  v.length = total_l;
  var idx = 0;
  for(var i$1 = 0 ,i_finish$1 = vs.length; i$1 < i_finish$1; ++i$1){
    var crr_v$1 = Caml_array.get(vs.data, i$1);
    for(var j = 0 ,j_finish = crr_v$1.length; j < j_finish; ++j){
      Caml_array.set(v.data, idx, Caml_array.get(crr_v$1.data, j));
      idx = idx + 1 | 0;
    }
  }
  return v;
}

function append(v, v2) {
  var l = v.length + v2.length | 0;
  ensure_capacity(l, v);
  for(var i = 0 ,i_finish = v2.length; i < i_finish; ++i){
    Caml_array.set(v.data, i + v.length | 0, Caml_array.get(v2.data, i));
  }
  v.length = l;
  
}

function flat_map(f, v) {
  var v2 = make(v.growth_rate, v.length, undefined);
  for(var i = 0 ,i_finish = v.length; i < i_finish; ++i){
    append(v2, Curry._1(f, Caml_array.get(v.data, i)));
  }
  return v2;
}

function cartesian_product(a, b) {
  return map2((function (a, b) {
                return [
                        a,
                        b
                      ];
              }), a, b);
}

function iter(f, v) {
  for(var i = 0 ,i_finish = v.length; i < i_finish; ++i){
    Curry._1(f, Caml_array.get(v.data, i));
  }
  
}

function iteri(f, v) {
  for(var i = 0 ,i_finish = v.length; i < i_finish; ++i){
    Curry._2(f, i, Caml_array.get(v.data, i));
  }
  
}

function filter(f, v) {
  var v2 = make(v.growth_rate, v.length, undefined);
  var l = 0;
  for(var i = 0 ,i_finish = v.length; i < i_finish; ++i){
    var e = Caml_array.get(v.data, i);
    if (Curry._1(f, e)) {
      Caml_array.set(v2.data, l, e);
      l = l + 1 | 0;
    }
    
  }
  v2.length = l;
  return v2;
}

function filteri(f, v) {
  var v2 = make(v.growth_rate, v.length, undefined);
  var l = 0;
  for(var i = 0 ,i_finish = v.length; i < i_finish; ++i){
    var e = Caml_array.get(v.data, i);
    if (Curry._2(f, i, e)) {
      Caml_array.set(v2.data, l, e);
      l = l + 1 | 0;
    }
    
  }
  v2.length = l;
  return v2;
}

function filter_in_place(f, v) {
  var old_l = v.length;
  var l = 0;
  for(var i = 0; i < old_l; ++i){
    var e = Caml_array.get(v.data, i);
    if (Curry._1(f, e)) {
      Caml_array.set(v.data, l, e);
      l = l + 1 | 0;
    }
    
  }
  for(var i$1 = l; i$1 < old_l; ++i$1){
    Caml_array.set(v.data, i$1, 0);
  }
  v.length = l;
  
}

function of_array(a) {
  var a$1 = $$Array.copy(a);
  return {
          growth_rate: 2,
          length: a$1.length,
          data: a$1
        };
}

function to_array(v) {
  return $$Array.sub(v.data, 0, v.length);
}

function of_list(l) {
  var a = $$Array.of_list(l);
  return {
          growth_rate: 2,
          length: a.length,
          data: a
        };
}

function to_list(v) {
  var _acc = /* [] */0;
  var _i = v.length - 1 | 0;
  while(true) {
    var i = _i;
    var acc = _acc;
    if (i === -1) {
      return acc;
    }
    _i = i - 1 | 0;
    _acc = {
      hd: Caml_array.get(v.data, i),
      tl: acc
    };
    continue ;
  };
}

function copy(v) {
  var a = $$Array.sub(v.data, 0, v.length);
  return {
          growth_rate: 2,
          length: a.length,
          data: a
        };
}

function rev_in_place(v) {
  var _i = 0;
  var _j = v.length - 1 | 0;
  while(true) {
    var j = _j;
    var i = _i;
    if (i >= j) {
      return ;
    }
    var temp = Caml_array.get(v.data, i);
    Caml_array.set(v.data, i, Caml_array.get(v.data, j));
    Caml_array.set(v.data, j, temp);
    _j = j - 1 | 0;
    _i = i + 1 | 0;
    continue ;
  };
}

function rev(v) {
  var a = $$Array.sub(v.data, 0, v.length);
  var v$prime = {
    growth_rate: 2,
    length: a.length,
    data: a
  };
  rev_in_place(v$prime);
  return v$prime;
}

function exists(f, v) {
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === v.length) {
      return false;
    }
    if (Curry._1(f, Caml_array.get(v.data, i))) {
      return true;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function for_all(f, v) {
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === v.length) {
      return true;
    }
    if (!Curry._1(f, Caml_array.get(v.data, i))) {
      return false;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function mem(e) {
  return function (param) {
    return exists((function (param) {
                  return Caml_obj.caml_equal(e, param);
                }), param);
  };
}

function memq(e) {
  return function (param) {
    return exists((function (param) {
                  return e === param;
                }), param);
  };
}

function fold_left(f, z, v) {
  var _acc = z;
  var _i = 0;
  while(true) {
    var i = _i;
    var acc = _acc;
    if (i === v.length) {
      return acc;
    }
    _i = i + 1 | 0;
    _acc = Curry._2(f, acc, Caml_array.get(v.data, i));
    continue ;
  };
}

function fold_right(f, v, z) {
  var _acc = z;
  var _i = v.length - 1 | 0;
  while(true) {
    var i = _i;
    var acc = _acc;
    if (i <= 0) {
      return acc;
    }
    _i = i - 1 | 0;
    _acc = Curry._2(f, Caml_array.get(v.data, i), acc);
    continue ;
  };
}

function zip_with(f, v1, v2) {
  var min_length = v1.length < v2.length ? v1.length : v2.length;
  var max_gr = v1.growth_rate > v2.growth_rate ? v1.growth_rate : v2.growth_rate;
  var v = make(max_gr, min_length, undefined);
  v.length = min_length;
  for(var i = 0; i < min_length; ++i){
    Caml_array.set(v.data, i, Curry._2(f, Caml_array.get(v1.data, i), Caml_array.get(v2.data, i)));
  }
  return v;
}

function zip(v1, v2) {
  return zip_with((function (a, b) {
                return [
                        a,
                        b
                      ];
              }), v1, v2);
}

function sort_by(f, v) {
  shrink_to_fit(v);
  return $$Array.fast_sort(f, v.data);
}

function sort(v) {
  var f = Caml_obj.caml_compare;
  shrink_to_fit(v);
  return $$Array.fast_sort(f, v.data);
}

function equal_by(f, a, b) {
  if (a.length !== b.length) {
    return false;
  }
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === a.length) {
      return true;
    }
    if (!Curry._2(f, Caml_array.get(a.data, i), Caml_array.get(b.data, i))) {
      return false;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function equal(a, b) {
  return equal_by(Caml_obj.caml_equal, a, b);
}

function compare_by(f, a, b) {
  var l = a.length - b.length | 0;
  var match = l !== 0 ? (
      l < 0 ? [
          a.length,
          -1
        ] : [
          b.length,
          1
        ]
    ) : [
      a.length,
      0
    ];
  var min_l_ord = match[1];
  var min_l = match[0];
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === min_l) {
      return min_l_ord;
    }
    var ord = Curry._2(f, Caml_array.get(a.data, i), Caml_array.get(b.data, i));
    if (ord !== 0) {
      return ord;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function compare(a, b) {
  return compare_by(Caml_obj.caml_compare, a, b);
}

function pretty_print(fmt, v) {
  if (v.length === 0) {
    return "[]";
  }
  var buf = $$Buffer.create(2);
  $$Buffer.add_char(buf, /* '[' */91);
  $$Buffer.add_string(buf, Curry._1(fmt, Caml_array.get(v.data, 0)));
  for(var i = 1 ,i_finish = v.length; i < i_finish; ++i){
    $$Buffer.add_string(buf, "; ");
    $$Buffer.add_string(buf, Curry._1(fmt, Caml_array.get(v.data, i)));
  }
  $$Buffer.add_char(buf, /* ']' */93);
  return $$Buffer.contents(buf);
}

function iota(start, end$prime) {
  var l = Pervasives.abs(end$prime - start | 0) + 1 | 0;
  var v = make(undefined, l, undefined);
  var inc = function (_i, _crr) {
    while(true) {
      var crr = _crr;
      var i = _i;
      if (crr > end$prime) {
        return ;
      }
      Caml_array.set(v.data, i, crr);
      _crr = crr + 1 | 0;
      _i = i + 1 | 0;
      continue ;
    };
  };
  var dec = function (_i, _crr) {
    while(true) {
      var crr = _crr;
      var i = _i;
      if (crr < end$prime) {
        return ;
      }
      Caml_array.set(v.data, i, crr);
      _crr = crr - 1 | 0;
      _i = i + 1 | 0;
      continue ;
    };
  };
  if (start < end$prime) {
    inc(0, start);
  } else {
    dec(0, start);
  }
  v.length = l;
  return v;
}

function $great$pipe$eq(v, f) {
  return map(f, v);
}

function $great$great$eq(v, f) {
  return flat_map(f, v);
}

var Infix = {
  let$dotget_exn: get_exn,
  let$dotset_exn: set_exn,
  let$dotget: get,
  let$dotset: set,
  $eq$pipe$less: map,
  $great$pipe$eq: $great$pipe$eq,
  $less$$great: map,
  $less$star$great: apply,
  $eq$less$less: flat_map,
  $great$great$eq: $great$great$eq,
  $neg$neg: iota
};

function let$plus(v, f) {
  return map(f, v);
}

function let$star(v, f) {
  return flat_map(f, v);
}

var Let_syntax = {
  let$plus: let$plus,
  and$plus: cartesian_product,
  let$star: let$star,
  and$star: cartesian_product
};

var default_growth_rate = 2;

function as_read_only(prim) {
  return prim;
}

function as_write_only(prim) {
  return prim;
}

exports.default_growth_rate = default_growth_rate;
exports.make = make;
exports.copy = copy;
exports.as_read_only = as_read_only;
exports.as_write_only = as_write_only;
exports.length = length;
exports.capacity = capacity;
exports.growth_rate = growth_rate;
exports.set_growth_rate = set_growth_rate;
exports.clear = clear;
exports.get_exn = get_exn;
exports.set_exn = set_exn;
exports.get = get;
exports.set = set;
exports.ensure_capacity = ensure_capacity;
exports.reserve = reserve;
exports.shrink_to_fit = shrink_to_fit;
exports.push = push;
exports.pop = pop;
exports.map = map;
exports.mapi = mapi;
exports.map_in_place = map_in_place;
exports.singleton = singleton;
exports.map2 = map2;
exports.apply = apply;
exports.flatten = flatten;
exports.flat_map = flat_map;
exports.cartesian_product = cartesian_product;
exports.iter = iter;
exports.iteri = iteri;
exports.filter = filter;
exports.filteri = filteri;
exports.filter_in_place = filter_in_place;
exports.of_list = of_list;
exports.to_list = to_list;
exports.of_array = of_array;
exports.to_array = to_array;
exports.rev = rev;
exports.rev_in_place = rev_in_place;
exports.append = append;
exports.exists = exists;
exports.for_all = for_all;
exports.mem = mem;
exports.memq = memq;
exports.fold_left = fold_left;
exports.fold_right = fold_right;
exports.zip = zip;
exports.zip_with = zip_with;
exports.sort = sort;
exports.sort_by = sort_by;
exports.equal = equal;
exports.equal_by = equal_by;
exports.compare = compare;
exports.compare_by = compare_by;
exports.pretty_print = pretty_print;
exports.iota = iota;
exports.Infix = Infix;
exports.Let_syntax = Let_syntax;
/* No side effect */
